---
title: "智能计算及其应用"
tags: ai
---

## 遗传算法

**遗传算法** 是一类借鉴生物界自然选择和自然遗传机制的随机搜索算法。其基本思想为在求解问题时从多个解开始，然后通过一定的法则进行逐步迭代以产生新的解。

![genetic algorithm cp](/assets/ai_57.png)

![genetic algorithm](/assets/ai_56.png)

遗传算法的一般步骤：

（1） 使用随机方法或者其它方法，产生一个有$N$个染色体的初始群体  $pop(1), t := 1$ 
（2） 对群体中的每一个染色体$pop_i(t)$，计算其适应值

$$
f_i=fitness(pop_i(t))
$$

（3） 若满足停止条件，则算法停止；否则，以概率

$$
p_i=f_i/\sum_{j=1}^Nf_j
$$

从$pop(t)$中随机选择一些染色体构成一个新种群

$$
newpop(t+1)=\{pop_j(t)|j=1, 2, \cdots, N\}
$$

（4）以概率$p_c$进行交叉产生一些新的染色体，得到一个新的群体

$$
crosspop(t+1)
$$

（5）以一个较小的概率$p_m$使染色体的一个基因发生变异，形成$mutpop(t+1); t := t + 1$，成为一个新的群体

$$
pop(t)=mutpop(t+1)
$$

返回（2）。

遗传算法的特点包括：

- 遗传算法对所求解的优化问题没有太多的数学要求，由于进化特性，搜素过程中不需要问题的内在性质，可直接对结构对象进行操作。
- 利用随机技术指导对一个被编码的参数空间进行高效率搜索
- 采用群体搜索策略，易于并行化。
- 仅用适应度函数值来评估个体，并在此基础上进行遗传操作，使种群中个体之间进行信息交换。
- 遗传算法能够非常有效地进行概率意义的全局搜素。


### 遗传算法历史

### 编码

遗传算法不能直接处理问题空间的参数，因此必须将求解问题编码为遗传空间的染色体/个体。

#### 位串编码

**位串编码**（一维染色体编码方法）将问题空间的参数编码为一维排列的染色体的方法。位串编码有两种形式：

- 二进制编码：用若干二进制数表示一个个体，将原问题的解空间映射到位串空间 $B=\{0，1\}$上，然后在位串空间上进行遗传操作。
  - 类似于生物染色体的组成，算法易于用生物遗传理论解释，遗传操作如交叉、变异等易实现；算法处理的模式数最多。 
  - 相邻整数的二进制编码可能具有较大的Hamming距离，降低了遗传算子的搜索效率。 
  - 要先给出求解的精度.
  - 求解高维优化问题的二进制编码串长，算法的搜索效率低。

- Gray编码：将二进制编码通过一个变换进行转换得到的编码。 假设二进制串为$<\beta_1\beta_2\cdots\beta_n>$，Gray串为$<\gamma_1\gamma_2\cdots\gamma_n>$。

将二进制编码转换为Gray编码的公式为

$$
\gamma_k=\begin{cases}
\beta_1 & k = 1\\
\beta_{k-1}\oplus\beta_k & k > 1
\end{cases}
$$

将Gray编码转换为二进制编码的公式为

$$
\beta_k=\sum_{i=1}^k\gamma_i\pmod{2}
$$

#### 实数编码

**实数编码**用若干实数表示一个整体，然后直接在实数空间上进行遗传操作。

#### 多参数映射编码

**多参数映射编码**先把每个参数进行二进制编码得到子串，然后把这些子串连成一个完整的染色体。

### 群体

#### 初始种群

- 随机产生群体规模数目的个体作为初始群体。 
- 随机产生一定数目的个体，从中挑选最好的个体加到初始群体中。这种过程不断迭代，直到初始群体中个体数目达到了预先确定的规模。 
- 根据问题固有知识，把握最优解所占空间在整个问题空间中的分布范围，然后，在此分布范围内设定初始群体。

#### 种群规模

- 群体规模太小，遗传算法的优化性能不太好，易陷入局部最优解。
- 群体规模太大，计算复杂。 
- 模式定理表明：群体规模为$M$，则遗传操作可从这$M$个个体中生成和检测$M^3$个模式，并在此基础上能够不断形成和优化积木块，直到找到最优解。
- 种群规模一般取20~100.

### 适应度函数

**适应度函数** 是用来区分群体中个体好坏的标准。

若目标函数为最大化问题，则

$$
Fit(f(x))=f(x)
$$

若目标函数为最小化问题，则

$$
Fit(f(x))=\frac{1}{f(x)}
$$

若目标函数为最大化问题，且需要保证适应度非负，则

$$
Fit(f(x))=\begin{cases}
f(x)-C_\mathrm{min} & f(x)>C_\mathrm{min}\\
0 & \text{otherwise}
\end{cases}
$$

若目标函数为最小化问题，且需要保证 适应度非负，则

$$
Fit(f(x))=\begin{cases}
C_\mathrm{max}-f(x) & f(x) < C_\mathrm{max} \\
0 & \text{otherwise}
\end{cases}
$$

#### 适应度函数的尺度变换

在遗传算法中，将所有妨碍适应度值高的个体产生，从而影响遗传算法正常工作的问题统称为**欺骗问题**。解决方案包括：

- **过早收敛**：缩小这些个体的适应度，以降低这些超级个体的竞争力。
- **停滞现象**：改变原始适应值的比例关系，以提高个体之间的竞争力。
- **尺度变换**（fitness scaling）或定标：对适应度函数值域的某种映射变换。 

（1） 线性变换

$$
f^\prime=af+b
$$

需要满足$f^\prime_\mathrm{avg}=f_\mathrm{avg},f^\prime _{\mathrm{max}}=C _ \mathrm{mult}\cdot f_\mathrm{avg}$. 

选择参数为：

$$
a=\frac{(C_\mathrm{mult}-1)f_\mathrm{avg}}{f_\mathrm{max}-f_\mathrm{avg}}\\
b=\frac{(f_\mathrm{max}-C_\mathrm{mult}f_\mathrm{avg})f_\mathrm{avg}}{f_\mathrm{max}-f_\mathrm{avg}}
$$

若需满足最小适应度值为非负，则选择

$$
a=\frac{f_\mathrm{avg}}{f_\mathrm{avg}-f_\mathrm{min}}\\
b=\frac{-f_\mathrm{min}f_\mathrm{avg}}{f_\mathrm{avg}-f_\mathrm{min}}
$$

（2）幂函数变换法

$$
f^\prime=f^K
$$

（3）指数变换法

$$
f^\prime=\mathrm{e}^{-af}
$$

### 选择

**选择操作**也称为复制（reproduction）操作：从当前群体中按照一定概率选出优良的个体，使它们有机会作为父代繁殖下一代子孙。个体适应度越高，其被选择的机会就越多。

#### 个体选择概率分配方法

（1）**适应度比例方法**（蒙特卡洛法）：各个个体被选择的概率和其适应度值成比例。

$$
p_{si}=\dfrac{f_i}{\displaystyle\sum_{i=1}^M f_i}
$$

（2）**排序方法**：群体成员按适应值大小依次排列：$x_1, x_2, \cdots, x_N$，个体$x_i$分配概率$p_i$，按照转盘式选择的方式选择父体。

①线性排序：

$$
p_i=\frac{a-bi}{M(M+1)}
$$

②非线性排序：

$$
p_i=\begin{cases}
q(1-q)^{i-1} & i = 1, 2, \cdots, M-1\\
(1-q)^{M-1} & i = M
\end{cases}
$$

③其他排序方法。只要函数$f$满足：

a. 

$$
\text{if } P=\{x_1, x_2, \cdots, x_M\} \text{ and } f(x_1)\ge f(x_2)\ge\cdots\ge f(x_M), \text{ then }\\
p_1\ge p_2\ge \cdots\ge p_M
$$

b. 

$$
\sum_{i=1}^M p_i=1
$$

#### 选择个体方法

（1）轮盘赌选择：

- 按个体的选择概率产生一个轮盘，轮盘每个区的角度与个体的选择概率成比例。
- 产生一个随机数，它落入转盘的哪个区域就选择相应的个体交叉。 

![rr](/assets/ai_58.png)

（2）锦标赛选择方法：从群体中随机选择个个体，将其中适应度最高的个体保存到下一代。这一过程反复执行，直到保存到下一代的个体数达到预先设定的数量为止。 

（3）随即竞争方法：每次按赌轮选择方法选取一对个体，然后让这两个个体进行竞争，适应度高者获胜。如此反复，直到选满为止。  

（4）最佳个体保存方法：把群体中适应度最高的个体不进行交叉而直接复制到下一代中，保证遗传算法终止时得到的最后结果一定是历代出现过的最高适应度的个体。 

### 交叉

两个生物体配对、复制时，他们的染色体相互混合，产生一个由双方基因组成的新染色体组，称为**重组**或**交叉**。

交叉概率$P_c$用来确定两个染色体进行局部交换来产生两个新的子代的概率。

- 较大的$P_c$可以增强遗传算法开辟新搜索区域的能力。
- 过大的$P_c$会增加破坏高性能模式的可能性。
- $P_c$的一个理想取值是0.7 

#### 基本交叉算子

（1）一点交叉：在个体串中随机设定一个交叉点，实行交叉时，该点前或后的两个个体的部分结构进行互换，并生成两个新的个体。 

（2）二点交叉：随机设置两个交叉点，将两个交叉点之间的码串相互交换。 

（3）多点交叉：类似于二点交叉，有多个交叉点。

#### 修正交叉方法

如部分匹配交叉PMX：

![pmx](/assets/ai_59.png)

### 变异

基因传递给后代的过程中，会有微小的概率发生差错，从而导致基因发生微小的改变，这就是**变异**。

变异概率太大会使得遗传算法趋于纯粹的随机搜索。变异概率$P_m$通常取0.001左右。

+ 位点变异：群体中的个体码串，随机挑选一个或多个基因座，并对这些基因座的基因值以变异概率作变动。
+ 逆转变异：在个体码串中随机选择两点（逆转点），然后将两点之间的基因值以逆向排序插入到原位置中。 
+ 插入变异：在个体码串中随机选择一个码，然后将此码插入随机选择的插入点中间。 
+ 互换变异：随机选取染色体的两个基因进行简单互换。
+ 移动变异：随机选取一个基因，向左或者向右移动一个随机位数。

## 🐔